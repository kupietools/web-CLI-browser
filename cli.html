<!DOCTYPE html>
<html>
<!-- Thanks for your curiosity, ya big ol' geek! michaelkupietz.com CLI interface by Michael Kupietz CLI@michaelkupietz.com -->
<!-- Much thanks to the Indieweb Homebrew Website Club Europe/London for much inspiration and input -->
<!-- Copyright (C) 2025  Michael E Kupietz.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/gpl-3.0-standalone.html>.

-->

<head>
<!-- link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Chivo+Mono:ital,wght@0,100..900;1,100..900&family=VT323&display=swap" rel="stylesheet" -->

 <meta charset="UTF-8">
<style id="bodystyle">/* styles that shouldn't be in downoad files go here. */
 body {
     
  
    margin: 0;
    padding: 20px;
    height: 100vh;
    overflow: hidden;
      /* had these, but needs more work... text input color & sizew didn't match
        font-size:14px;
        font-family: "Chivo Mono", monospace,"VT323";
  font-optical-sizing: auto;
  font-weight: 400;
  font-style: normal;
        */
}
</style>
<style id="cli_doc_style">
       
body {  background: #1a1a1a;
    color: #ccc; /* #3f3;*/ /* dimmer base green */
font-family: monospace;}
.text-title {
    color: #5af; /* bright blue */
}
.text-header {
    color: #ff9; /* bright white for headers instead of green */
text-transform: uppercase;
}
.text-link {
    color: #f5f; /* bright magenta */
  font-size:10px;
}
.text-list {
  /*  color: #ff5;*/ /* bright yellow */ 
}
.text-quote {
    color: #5ff; /* bright cyan */
}
.text-bold {
    color: #f99; /* bright white */
}
.text-anchor {
    color: #8ef; /* bright white */
}
.text-summary {
    color: #9f9; /* bright white */
}.text-summary::before {
    text-content: '&#9654'; /* bright white */
}
.text-detail {
    color: #6c9; /* bright white */
}

.mmarker-child-a { color: #ff5;}
.screen-reader-text {display: none;}

.h6 {
	text-transform: uppercase;
	/*letter-spacing: 2px;*/
	font-size: .6875em;
	/*display: block;*/
    color:#def;
	font-weight: 400;
	font-style: normal;

}
.h6:after {content:": ";}

.meta-genre-term {font-size: .6875em;   color:#99F;


display: inline-block !important;

	padding: 2px 3px !important;
	line-height: 0.75em;
	/* border: 2px solid #33c6ff !important;*/
	/* background: #ccc /* #33c6ff */ !important; */
	width: auto;
	font-weight: 400 !important;
border-radius:3px;
margin-inline:1px;


}
.titleprefix {/* color:#FFC; */text-transform: capitalize;}
.titleprefix:after {content:': ';}

        #terminal {
            height: calc(100vh - 40px);
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding-bottom: 40px;
        }
        #input-line {
            display: flex;
            align-items: initial ; /*center; caused problems if input wrapped*/
            margin-top: 1rem;
        }
        /* #prompt { NO makes input text shift 8px to the right, then move left when line is entered
            margin-right: 8px;
        } */
      #command-input {
    background: transparent;
    border: none;
    color: #ccc;/* #33ff33; */
    font-family: monospace;
    font-size: inherit;
    flex-grow: 1;
    outline: none;
    padding: 0;
    margin: 0;
    display: inline-block;
    caret-color: transparent;
      height:inherit;
}
#prompt {
  min-width: fit-content;
}

#command-input br {
	display: none; /* needed because firefox adds a <br> if you vackspace in an empty contenteditable */
}

#command-input:focus::after { /* :focus makes sure no cursor blink when can't type because not in field */
    content: "█";
 color: #ccc;/* #33ff33; */
    animation: blink 1s steps(1) infinite;

}
.spacers {color:#333;}

@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.25; }
}


@keyframes rainbow {
    0% { color: red; }
    15% { color: orange; }
    30% { color: yellow; }
    45% { color: green; }
   60% { color: blue; }
    75% { color: indigo; }
    90% { color: violet; }

   
}

 .output {
            margin: 0; /* 10px 0; left blank lines in More */
        }
.error {
            color: #ff3333;
        }
.loading {
            /* color: #ffff33; */
            animation: blink 1s steps(1) infinite, rainbow 2s  infinite ;
        }
.more-prompt {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            padding: 10px 20px;
            border-top: 1px solid #33ff33;
        }
    
    #input-line.hidden {
    display: none;
}
    </style>
</head>
<body><div id="terminal"><div class="output">*** KUPIETZ ARTS+CODE ***<p>&nbsp;&nbsp;&nbsp;&nbsp;7167 BYTES FREE<p>
Welcome to CLI browsing mode.<br>Type '<span id="helplang">help</span>' for available commands.</div><div id="input-line" class="">
    <span id="prompt">$ </span>
    <div id="command-input" contenteditable="true" autofocus=""></div>
</div>
    </div>

    <script>
 
     let theseOptions = {prompt:"vt100",language:"cli-html",flavor:"",starturl:"",forceuppercase:false}; /* all acceptable url parameters must be listed here or they will be ignored */
const urlParams = new URLSearchParams(window.location.search);

    for (const key in theseOptions) {
      if (urlParams.has(key)) { /* this is where urlparams with no key above get disregarded */
        theseOptions[key] = urlParams.get(key);
      }
    }
    
    
    if (theseOptions["forceuppercase"]) {document.body.style.textTransform="uppercase"; /* I did NOT make all-caps the default to give you that vintage 1980 personal computer experience, because I'm a nice guy. You kids don't know how good you have it. */}

    
   console.log(theseOptions["prompt"]);
    
    let prompts={"vt100":()=>{return currentUrl ? `[${currentUrl}]$ ` : '$ ';},
                 "apple":()=>'] ',"pet":()=>"READY."};
    if (theseOptions["prompt"]=="pet") {document.getElementById("input-line").style.flexDirection="column";promptLineBreak="\n";}
    let languages={"cli-html":{},
                   "unix":{"curl":"open","cat":"display","ls":"links","man":"help","cd":"follow"},
                 "basic":{"load":"open","run":"display","list":"links","goto":"follow"},
                 "piglatin":{"earclay":"clear","isplayday":"display","exitway" : "exit","ollowfay":"follow","orwardfay":"forward","epgray":"grep","elphay":"help","intshay":"hints","inkslay":"links","oremay":"more","efreshray":"refresh","ersionsvay":"versions","udosay":"sudo"}
                };
    
    const cmdDict = {};
    // Process each language
    for (const language in languages) {
      cmdDict[language] = {};
      // Create reverse mapping for this language
      for (const key in languages[language]) {
        const value = languages[language][key];
        cmdDict[language][value] = key;
      }
    }
 

    document.getElementById("helplang").textContent=cmdInLang("help");
const commandInput = document.getElementById('command-input');

commandInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
        e.preventDefault(); // Prevent default newline
        const commandLine = commandInput.textContent.trim();
        commandInput.textContent = ''; // Clear the input
        
        if (commandLine) {
            commandHistory.push(commandLine);
            addOutput(`\n${promptSpan.textContent}${promptLineBreak}${commandLine}`);
            
            const result = await executeCommand(commandLine);
            if (result) {
                addOutput(result);
            }
            
            if (!currentMoreOutput) {
                terminal.scrollTop = terminal.scrollHeight;
            }
        }
    }
});

// Optional: Prevent pasting formatted text
commandInput.addEventListener('paste', (e) => {
    e.preventDefault();
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
});
        const terminal = document.getElementById('terminal');
        const input = document.getElementById('command-input');
        const promptSpan = document.getElementById('prompt');
        const urlPattern = /^(https?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?$/;
        
        const PROXY_SERVICES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://cors-anywhere.herokuapp.com/${url}`,
            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
        ];
        
        let currentLinks = [];
        let currentUrl = '';
        let pageCache = new Map();
        let currentMoreOutput = null;
        let currentCommand = null;
        let isCommandRunning = false;
        let currentProxyIndex = 0;
        let morePromptDiv = null;
        let originalURL = "";
        
        // New variables for history tracking
        let pageHistory = [];
        let currentHistoryIndex = -1;
        
        const commandHistory = [];
        let historyIndex = -1;
        let currentInput = '';
        let firstSudo=true;

        const SIGNALS = {
            SIGINT: '^C',
            SIGTSTP: '^Z',
            SIGQUIT: '^\\'
        };

        function decodeHtmlEntities(text) {
    
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            return textarea.value;
        }

        function getTerminalDimensions() {
            const lineHeight = 40;
            const promptHeight = 40;
            const height = Math.floor((terminal.clientHeight - promptHeight) / lineHeight);
            const width = Math.floor(terminal.clientWidth / 8);
            return { height, width };
        }

        function truncateLines(text, width) {
            return text.split('\n').map(line => 
                line.length > width ? line.slice(0, width - 3) + '...' : line
            ).join('\n');
        }

      

function updatePrompt() {
    promptSpan.textContent = prompts[theseOptions.prompt]();/*was currentUrl ? `[${currentUrl}]$ ` : '$ '; */
console.log("P",theseOptions.prompt,prompts[theseOptions.prompt],prompts[theseOptions.prompt]());
}

    function toggleInputLine(show) {
    const inputLine = document.getElementById('input-line');
    if (show) {
        inputLine.classList.remove('hidden');
        input.focus();
    } else {
        inputLine.classList.add('hidden');
    }
}

      function addOutput(text, className = 'output') {
    const output = document.createElement('div');
    output.className = className;
    if (typeof text === 'string' && !text.includes('</')) {
        output.textContent = text;
    } else {
        output.innerHTML = text;
       
    }
    terminal.insertBefore(output, input.parentElement);
    terminal.scrollTop = terminal.scrollHeight;
    return output;
}

        function showMorePrompt(text) {
            if (morePromptDiv) {
                morePromptDiv.remove();
            }
            morePromptDiv = document.createElement('div');
            morePromptDiv.className = 'more-prompt';
            morePromptDiv.textContent = text;
            document.body.appendChild(morePromptDiv);
        }

        function removeMorePrompt() {
            if (morePromptDiv) {
                morePromptDiv.remove();
                morePromptDiv = null;
            }
        }

   function displaySignal(signal) {
    const currentLine = commandInput.textContent;
    commandInput.textContent = '';
    addOutput(`${promptSpan.textContent}${currentLine}${signal}`);
}


 function createMoreHandler(fullText) {
    const dims = getTerminalDimensions();
    
    // Split into lines while preserving HTML tags
    const lines = [];
    let currentLine = '';
    let inTag = false;
    let tagBuffer = '';
    let tagStack = [];
    
    // First split on newlines while preserving HTML tags
    for (let i = 0; i < fullText.length; i++) {
        const char = fullText[i];
        
        if (char === '<') {
            inTag = true;
            tagBuffer = char;
        } else if (char === '>') {
            inTag = false;
            tagBuffer += char;
            
            // Check if this is a closing tag
            if (tagBuffer.startsWith('</')) {
                tagStack.pop();
            } else if (!tagBuffer.endsWith('/>')) { // Not a self-closing tag
                const tagName = tagBuffer.match(/<([^\s>]+)/)?.[1];
                if (tagName) tagStack.push(tagName);
            }
            
            currentLine += tagBuffer;
            tagBuffer = '';
        } else if (inTag) {
            tagBuffer += char;
        } else if (char === '\n') {
            // Only split at newlines if we're not in the middle of a tag
            if (!inTag) {
                lines.push(currentLine);
                currentLine = '';
            } else {
                currentLine += char;
            }
        } else {
            currentLine += char;
        }
    }
    
    if (currentLine) {
        lines.push(currentLine);
    }
    
    let position = 0;
    
    function displayMore() {
        if (position >= lines.length) {
            currentMoreOutput = null;
            removeMorePrompt();
            toggleInputLine(true);
            return null;
        }
        
        const endPosition = Math.min(position + dims.height - 1, lines.length);
        const output = lines.slice(position, endPosition).join('\n');
       
        position = endPosition;
        
        const percentage = Math.floor((position / lines.length) * 100);
        const lineInfo = `lines ${position}/${lines.length}`;
        
        addOutput(output);
        
        if (position < lines.length) {
            showMorePrompt(`--Press Space For More--${lineInfo} (${percentage}%)`);
            return '';
        }
        
        removeMorePrompt();
        toggleInputLine(true);
        return null;
    }
    
    return {
        next: displayMore,
        cancel: () => {
            removeMorePrompt();
            toggleInputLine(true);
            const remainingLines = lines.length - position;
            return `...output cancelled (${remainingLines} lines remaining)`;
        }
    };
}
    
    
    /**
   * Triggers browser file download with specified content
   * @param {string} output - Content to be downloaded
   * @param {string} filename - Name of the file to be downloaded
   */
  function download_txt(output, myFile) {
    // Create a blob with the output content
  thisStyle=document.getElementById("cli_doc_style").innerHTML;
  output='<!doctype HTML><html><head><style>'+thisStyle+'</style><body>'+output.replace(/(?:\r\n|\r|\n)/g,"<br>")+'</body></html>';
    const blob = new Blob([output], { type: 'text/html' });

    // Create a URL for the blob
    const url = URL.createObjectURL(blob);

    // Create a temporary anchor element
    const a = document.createElement('a');
    a.href = url;
    a.download = myFile;

    // Append to the document, click it, then remove it
    document.body.appendChild(a);
    a.click();

    // Clean up
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
   return blob.size+" bytes written for download";
  }
async function fetchWithRetry(url) {
    let lastError;
    const loadingIndicator = addOutput(`Loading ${url}... waiting for data (0s)`, 'loading');
    let startTime = Date.now();
    let waitTimer = setInterval(() => {
        const seconds = Math.floor((Date.now() - startTime) / 1000);
        loadingIndicator.textContent = `Loading ${url}... waiting for data (${seconds}s)`;
    }, 1000);
    
    // Check if URL is same origin and try direct fetch first


if (new URL(url).origin === window.location.origin) {
    // Add mklynx parameter to URL
    const modifiedUrl = new URL(url);
 modifiedUrl.searchParams.append('mklynx', '1'); 
    try {
        const response = await fetch(modifiedUrl);


/* that was to add parameter. Orig was 
    if (new URL(url).origin === window.location.origin) {
        try {
            const response = await fetch(url); */
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            clearInterval(waitTimer);
            const reader = response.body.getReader();
            const contentLength = response.headers.get('Content-Length') || 0;
            let receivedLength = 0;
            let chunks = [];

            while(true) {
                const {done, value} = await reader.read();
                if (done) break;
                chunks.push(value);
                receivedLength += value.length;
                
                const percent = contentLength ? 
                    Math.round((receivedLength / contentLength) * 100) :
                    `${(receivedLength / 1024).toFixed(1)}KB`;
                loadingIndicator.textContent = contentLength ?
                    `Loading ${url}... ${percent}% (${(receivedLength / 1024).toFixed(1)}KB of ${(contentLength / 1024).toFixed(1)}KB)` :
                    `Loading ${url}... ${percent} received`;
            }

            loadingIndicator.remove();
            const chunksAll = new Uint8Array(receivedLength);
            let position = 0;
            for(let chunk of chunks) {
                chunksAll.set(chunk, position);
                position += chunk.length;
            }
            return new TextDecoder("utf-8").decode(chunksAll);
        } catch (err) {
            console.log('Direct fetch failed:', err);
            // Fall through to proxy system
        }
    }

    // Original proxy logic unchanged
    for (let i = 0; i < PROXY_SERVICES.length; i++) {
        const proxyUrl = PROXY_SERVICES[(currentProxyIndex + i) % PROXY_SERVICES.length](url);
        try {
            const response = await fetch(proxyUrl, {
                headers: {
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            clearInterval(waitTimer);
            const reader = response.body.getReader();
            const contentLength = response.headers.get('Content-Length') || 0;
            let receivedLength = 0;
            let chunks = [];

            while(true) {
                const {done, value} = await reader.read();
                if (done) break;
                chunks.push(value);
                receivedLength += value.length;
                
                const percent = contentLength ? 
                    Math.round((receivedLength / contentLength) * 100) :
                    `${(receivedLength / 1024).toFixed(1)}KB`;
                loadingIndicator.textContent = contentLength ?
                    `Loading ${url}... ${percent}% (${(receivedLength / 1024).toFixed(1)}KB of ${(contentLength / 1024).toFixed(1)}KB)` :
                    `Loading ${url}... ${percent} received`;
            }

            currentProxyIndex = (currentProxyIndex + i) % PROXY_SERVICES.length;
            loadingIndicator.remove();
            
            const chunksAll = new Uint8Array(receivedLength);
            let position = 0;
            for(let chunk of chunks) {
                chunksAll.set(chunk, position);
                position += chunk.length;
            }
            return new TextDecoder("utf-8").decode(chunksAll);
        } catch (err) {
            lastError = err;
            loadingIndicator.textContent = `Loading ${url}... Retrying with different proxy (${err.message})`;
            continue;
        }
    }
    
    clearInterval(waitTimer);
    loadingIndicator.remove();
  /* was  throw lastError; but wanted more detail */
throw new Error(`Sorry, we couldn't load ${url} right now after trying ${PROXY_SERVICES.length} different methods. This could be because the site is down, blocking access, or our connection methods aren't working. Last error was: ${lastError}. The site may be blocking proxy access. Please try again in a few minutes.`);


}
    

function processNode(node, linkMap, indent = 0) {
    let content = '';
    let spacer = '<span class="spacers">'+('|       '.repeat(indent))+'</span>';
    if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) {
            const parentAnchor = node.parentElement.closest('a');
            if (parentAnchor && linkMap.has(parentAnchor)) {
                if (!parentAnchor._numbered) {
                    content += `<span class="text-link">[${linkMap.get(parentAnchor) + 1}]</span>`;
                    parentAnchor._numbered = true;
                }
            }
            content += text;
        }
        return content;
    }

    if (node.nodeType !== Node.ELEMENT_NODE) {
        return content;
    }

    const tagName = node.tagName.toLowerCase();
    
    if (['script', 'style', 'iframe', 'noscript'].includes(tagName)) {
        return '';
    }

    switch (tagName) {
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
            content += `\n<!-- 546 -->${spacer}<span class="text-header">${'='.repeat(indent + 2)} `;
            break;
            
        case 'blockquote':
            content += `\n<!-- 550 -->${spacer}<span class="text-quote">`;
            break;
         case 'summary':
            content += `\n<!-- 553 -->${spacer}<span class="text-summary">`;
            break;
         case 'details':
            content += `<span class="text-detail">`;
            break;
            
        case 'strong':
        case 'b':
            content += `<span class="text-bold">`;
            break;
                
        case 'a':
            content += `<span class="text-anchor">`;
            break;
  
        case 'p':
        case 'div':
        case 'section':
        case 'article':
            if (node.textContent.trim()) {
                content += '\n<!-- 574 -->'+(spacer);
            }
            break;
            
        case 'br':
            content += '\n<!-- 578 -->'+(spacer);
            break;
            
        case 'li':
           if (!(node.classList.contains('postscroll')||node.classList.contains('menusection'))) {   content += /*\n*/`\n<!-- 582 -->${spacer}<span class="text-list">• </span>`;}
            break; /* don't want the LIs with no real content on menus to display on their own lines with bullets */
            
        case 'ul':
        case 'ol':
          content += '\n<!-- 587 -->'+(spacer);
            indent += 1;
            break;
    }
    
  /*  if (node.classList.contains('h6')) {
        content += '\n\n'+(spacer);
    } */
 if (node.classList.contains('titleprefix') ) {
        content += '<span class="titleprefix">';
    }
    if (node.classList.contains('menutitleprefix') || node.classList.contains('h6')) {
        content += '<span class="h6 menutitleprefix">';
    }
 if (node.classList.contains('meta-genre-term')) {
        content += '<span class="meta-genre-term">';
    }

 if (node.classList.contains('screen-reader-text')) {
        content += '<span class="screen-reader-text">';
    }

 if (node.classList.contains('mmarker-child-a')) {
        content += '<span class="mmarker-child-a">';
    }



    // Process all child nodes
    for (const child of node.childNodes) {
        const childContent = processNode(child, linkMap, indent);
        // If this is a text node and we're inside a menutitleprefix span,
        // make sure we close the span before adding the text
        if (child.nodeType === Node.TEXT_NODE && 
            node.classList.contains('menutitleprefix')) {
            content += childContent;
        } else {
            content += childContent;
        }
    }
    
    if (node.classList.contains('h6') || node.classList.contains('titleprefix') || node.classList.contains('menutitleprefix') || node.classList.contains('meta-genre-term') || node.classList.contains('screen-reader-text') || node.classList.contains('mmarker-child-a')) {
        content += '</span>';
    }
    if (node.classList.contains('h6')) {
        content += '\n'+(spacer);
    }
    
    switch (tagName) {
       case 'ul':
        case 'ol':
          content += '\n<!-- 587 -->'+(spacer);
          
            break;
    
    
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
            content += `${'='.repeat(indent + 2)}</span>`;
            break;
            
        case 'blockquote':
            content += '</span><!-- 631 -->\n'+(spacer);
            break;
          case 'summary':
            content += '</span>\n<!-- 634 -->'+(spacer);
            break;
          case 'details':
            content += '</span>\n<!-- 637 -->'+(spacer);
            break;
            
        case 'strong':
        case 'b':
            content += '</span>';
            break;
            
        case 'a':
            content += '</span> ';
            break;
            
        case 'p':
        case 'div':
        case 'section':
        case 'article':
         /*   if (node.textContent.trim()) {
                content += '\n<!-- 653 -->'+(spacer);
            } ( */
            break;
    }
    
    return content;
}
    
    
     async function processHTML(html, url) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html  .replace(/&lt;/gi, '&amp;lt;'), 'text/html'); /* DOMparser automatically renders entities in text so code in the bodies made with fake entities renters is real code in the browser if you don't substitute. */
    
    const linkMap = new Map();
    const links = Array.from(doc.querySelectorAll('a')).map((a, index) => {
        if (a.href) {
            try {
                const resolvedUrl = new URL(a.href, url).href;
                linkMap.set(a, index);
                return {
                    text: a.textContent.trim(),
                    href: resolvedUrl
                };
            } catch (e) {
                return null;
            }
        }
        return null;
    }).filter(Boolean);

    let textContent = '';
    
    const title = doc.querySelector('title');
    if (title) {
        const titleText = decodeHtmlEntities(title.textContent.trim());
        textContent += '<span class="text-title">';
        textContent += '='.repeat(40) + '\n';
        textContent += titleText + '\n';
        textContent += '='.repeat(40) + '</span>\n\n';
    }

       
     
    textContent += processNode(doc.body, linkMap);
  
    textContent = textContent
        .replace(/\n{3,}/mg, '\n\n')
         .replace(/(\n[-<!0-9> ]*<span class="spacers">[ |]*<\/span>){3,}/igm, '$1$1')
        .replace(/[ \t]+/g, ' ')
        .trim();
    
    textContent += '\n\n' + '-'.repeat(40) + '\n';
    textContent += `${links.length} links found. Use 'links' command to show them.\n`;
    
    return { content: textContent, links };
}

    
    function locCmd(commandInput) {
   
    result = (cmdInLang(commandInput)!=commandInput)? "" : (languages[theseOptions["language"]][commandInput] || commandInput); /* make it so when using a language, the original commands fail if alternatives are defined for them */
    return result;
  
    };
    
    function cmdInLang(commandInput) {
    return cmdDict[theseOptions["language"]][commandInput]||commandInput;
    }
    
    
  async function executeCommand(commandLine, canInterrupt = true) {
    isCommandRunning = true;
    currentCommand = { canInterrupt };
    toggleInputLine(false);
    
    try {
        const pipes = commandLine.split('|').map(cmd => cmd.trim());
    
        let output = '';
        
        for (let i = 0; i < pipes.length; i++) {
            if (!currentCommand) {
                return '';
            }

            const [commandRaw, redirect, ...redirectArgs ] = pipes[i].split('>').map(cmd => cmd.trim());
    
        
            const [commandInput, ...args] = commandRaw.split(' ');
        command = locCmd(commandInput.toLowerCase()) ;
            
            if (command === 'more') {
                if (!output) {
                    return 'No input to more';
                }
                currentMoreOutput = createMoreHandler(output);
             console.log(1,commandRaw,command);
                return currentMoreOutput.next();
           
            }
            console.log(2,commandRaw,command);
            const cmd = commands[command];
            if (!cmd) {
            return '\n?SYNTAX ERROR';
               /* return `Command not found: ${command}`; */
            }
            
            // Pass the previous output as the last argument for piped commands
            if (i > 0) {
                args.push(output);
            }
            
            const result = await cmd(...args);
            output = (redirect==undefined)?(result || ''):download_txt(result,redirect);
        }
        
        return output;
    } finally {
        isCommandRunning = false;
        currentCommand = null;
        if (!currentMoreOutput) {
            toggleInputLine(true);
        }
    }
}  
    
    
    
        const commands = { /* hid - open [url]     : Load a website in text mode from help */
        versions: () => `
Version History:
2025apr9 - add '>' download redirect, versions command, settings for prompts/languages/force all caps/other secret sauce by URL parameter, add message to confirm page has loaded.
2025apr8 - first working version
        `,
           help: () => `
Available commands:
- ${cmdInLang("display")}                    : Show the current page
- ${cmdInLang("clear")}                      : Clear the terminal
- ${cmdInLang("links")}                      : Show all links on the current page
- ${cmdInLang("follow")} [num]               : Follow a link by its number
- ${cmdInLang("back")}                       : Go back to the previous page
- ${cmdInLang("forward")}                    : Go forward to the next page
- ${cmdInLang("refresh")}                    : Reload last loaded page
- ${cmdInLang("hints")}                      : A mysterious command, I don't know what it does.
- ${cmdInLang("versions")}                   : Version history/changelog of this browser
- ${cmdInLang("exit")}                       : Return to GUI browser
- [command1] | [command2]    : Redirect output into another command such as 'grep' or 'more'
- [command] > filename.html  : Redirect output to a file download in accordance with your browser's settings, rather than onscreen
- ${cmdInLang("grep")} [pattern]             : Filter output by regular expression. Case-insensitive
- ${cmdInLang("more")}                       : Paginate output. [space] to continue. Esc, ctrl-c, or q to quit
- ${cmdInLang("help")}                       : Show this help message

Startup URL paramaters (capitalized value is default used when none specified):
- prompt  [UNIX|pet|apple]                   : The style of command prompt
- language [CLI-HTML|unix|basic|piglatin]    : Language set of the commands. The ${cmdInLang("help")} command (whatever it is in the currently selected language) always shows all commands in the correct form for that language.`,
        /* note, in unix mode, "screen" should be STDOUT */
        
hints: () => `
- If you ${cmdInLang("open")} a can of worms, you do so at your own risk.
- You can do as the super user says, not as the super user does.
- Don't be startled by hollow voices. 
`,
              
            clear: () => {
                const outputs = terminal.querySelectorAll('.output');
                outputs.forEach(output => output.remove());
                return '';
            },
xyzzy: () => {return "\nA hollow voice says 'fool'";},
            display: async () => {
                if (!currentUrl) {
                    return 'No page currently loaded.';
                }
                return commands.open(currentUrl, false);
            },

          back: async () => {
    if (currentHistoryIndex <= 0) {
        return 'No previous pages in history.';
    }
    toggleInputLine(false);
    currentHistoryIndex--;
    const result = await commands.open(pageHistory[currentHistoryIndex], false);
    if (!currentMoreOutput) {
        toggleInputLine(true);
    }
    return result;
},
        
        forward: async () => {
    if (currentHistoryIndex >= pageHistory.length - 1) {
        return 'No forward pages in history.';
    }
    toggleInputLine(false);
    currentHistoryIndex++;
    const result = await commands.open(pageHistory[currentHistoryIndex], false);
    if (!currentMoreOutput) {
        toggleInputLine(true);
    }
    return result;
},

        
 sudo: async (user) => {
    const line = document.createElement('div');
    line.style.display = 'inline-block';
    line.style.whiteSpace = 'pre';
    line.contentEditable = 'true';
    line.style.outline = 'none';
   /* line.style.width = '200x';  // Fixed width
    line.style.height = '1.2m'; // Fixed height 
    NOT NEEDED */
    line.style.color = 'transparent';
    line.style.caretColor = '#3f3';
    line.style.verticalAlign = 'top'; // Prevent vertical movement
if (firstSudo == true) {
    addOutput(`
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

`);firstSudo=false;}

    let attempts = 0;
    while (attempts < 3) {
      //  const promptDiv = addOutput(`${user}'s password: `, 'output'); NAH, it should be  sudo command, not sudo user. */
    const promptDiv = addOutput(`Password: `, 'output');
        promptDiv.appendChild(line);
        line.focus();

        const password = await new Promise(resolve => {
            const handler = e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    line.removeEventListener('keydown', handler);
                    resolve(line.textContent);
                }
            };
            line.addEventListener('keydown', handler);
        });

      /*  promptDiv.removeChild(line); THIS WASN'T EVEN NEEDED. */
        line.textContent = '';
        addOutput('');
        
        attempts++;
        if (attempts < 3) {
            addOutput('Sorry, try again.');
        } else {
            addOutput('sudo: 3 incorrect password attempts');
        }
    }
    return '';
},

        grep: (pattern, prevOutput) => {
    if (!pattern) {
        return 'Error: grep requires a pattern';
    }
    try {
        const regexp = new RegExp(pattern, 'i');
        const lines = (prevOutput || '').split('\n');
        const matches = lines.filter(line => regexp.test(line));
        return matches.join('\n');
    } catch (e) {
        return `Error: Invalid ${cmdInLang("grep")} expression - ${e.message}`;
    }
},

exit: () => {
const now = new Date();
window.location.href=(currentUrl?currentUrl:originalURL); currentMoreOutput=true;return `Goodbye!\n\nLogged out at ${now.toLocaleString()}`;}  ,      
        

            links: () => {
                if (!currentLinks || currentLinks.length === 0) {
                    return 'No links available. Load a page first using the open command.';
                }
                return currentLinks.map((link, i) => 
                    `<span class="text-link">[${i + 1}]</span> <span class="text-anchor">${link.text}</span> -> ${link.href}</a>`
                ).join('\n');
            },

            follow: async (num) => {
                if (!currentLinks || currentLinks.length === 0) {
                    return 'No links available. Load a page first using the open command.';
                }
                const index = parseInt(num) - 1;
                if (isNaN(index) || index < 0 || index >= currentLinks.length) {
                    return 'Invalid link number. Use the links command to see available links.';
                }
                return commands.open(currentLinks[index].href);
            },
refresh: async () => {return commands.open(currentUrl, false, true);},
           
        
        
        open: async (url, addToHistory = true, refresh=false) => {
    if (!url) return 'Error: Please provide a URL';

    if (!url.startsWith('http')) {
        url = 'https://' + url;
    }

    try {
        new URL(url);
    } catch (e) {
        return 'Error: Invalid URL format';
    }

    try {
        let content, links;
        let gotFromCache=pageCache.has(url) && refresh==false;
        if (gotFromCache) {
            ({ content, links } = pageCache.get(url));
        } else {
            try {
               
                const html = await fetchWithRetry(url);
                const result = await processHTML(html, url);
                content = result.content;
                links = result.links;
                if (content) {
                    pageCache.set(url, { content, links });
                }
            } catch (err) {
                throw new Error(`Failed to fetch: ${err.message}`);
            }
        }

        currentUrl = url;
        currentLinks = links;
        
        if (addToHistory) {
            if (currentHistoryIndex < pageHistory.length - 1) {
                pageHistory = pageHistory.slice(0, currentHistoryIndex + 1);
            }
            pageHistory.push(url);
            currentHistoryIndex = pageHistory.length - 1;
        }
        
        updatePrompt();
       if (content && !gotFromCache) {addOutput( url+" loaded, "+ content.length+" bytes received");}
        return "\n"+(content || 'Error: No content processed');
    } catch (err) {
        currentUrl = '';
        currentLinks = [];
        updatePrompt();
        return `\nError loading ${url}: ${err.message}`;
    }
}
        };

        document.addEventListener('keydown', async (e) => {
            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                
                if (currentMoreOutput) {
                    const cancelMsg = currentMoreOutput.cancel();
                    addOutput(SIGNALS.SIGINT);
                    currentMoreOutput = null;
                    updatePrompt();
                    return;
                }
                
                if (isCommandRunning && currentCommand?.canInterrupt) {
                    currentCommand = null;
                    displaySignal(SIGNALS.SIGINT);
                    updatePrompt();
                    return;
                }
                
                if (!isCommandRunning) {
                    displaySignal(SIGNALS.SIGINT);
                    updatePrompt();
                    return;
                }
            }

            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                displaySignal(SIGNALS.SIGTSTP);
                return;
            }

            if (e.ctrlKey && e.key === '\\') {
                e.preventDefault();
                displaySignal(SIGNALS.SIGQUIT);
                return;
            }

            if (currentMoreOutput) {
                e.preventDefault();
                
                if (e.key === 'Escape' || e.key === 'q') {
                    const cancelMsg = currentMoreOutput.cancel();
                    addOutput(cancelMsg);
                    currentMoreOutput = null;
                    updatePrompt();
                    return;
                }
                
                if (e.code === 'Space' || e.key === 'PageDown') {
                    const more = currentMoreOutput.next();
                    if (more !== null) {
                        addOutput(more);
                    } else {
                        updatePrompt();
                    }
                    return;
                }
                
                if (e.key === 'Enter') {
                    const more = currentMoreOutput.next();
                    if (more !== null) {
                        addOutput(more, true);
                    } else {
                        updatePrompt();
                    }
                    return;
                }
            }
        });

       commandInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const commandLine = commandInput.textContent.trim();
        commandInput.textContent = '';
        
        if (commandLine) {
            commandHistory.push(commandLine);
            historyIndex = -1;
            addOutput(`${promptSpan.textContent}${commandLine}`);
            
            const result = await executeCommand(commandLine);
            if (result) {
                addOutput(result);
            }
            
            if (!currentMoreOutput) {
                terminal.scrollTop = terminal.scrollHeight;
            }
        }
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex === -1) {
            currentInput = commandInput.textContent;
        }
        if (historyIndex < commandHistory.length - 1) {
            historyIndex++;
            commandInput.textContent = commandHistory[commandHistory.length - 1 - historyIndex];
            // Place cursor at end
            const range = document.createRange();
            const sel = window.getSelection();
            range.selectNodeContents(commandInput);
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
        }
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex > 0) {
            historyIndex--;
            commandInput.textContent = commandHistory[commandHistory.length - 1 - historyIndex];
        } else if (historyIndex === 0) {
            historyIndex = -1;
            commandInput.textContent = currentInput;
        }
        // Place cursor at end
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(commandInput);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }
});
 async function initialize() {
    toggleInputLine(false);
    let startUrl = document.referrer;
    if (!startUrl || startUrl.split('/')[2].split(':')[0].split(':')[0]!="michaelkupietz.com"){
        startUrl = window.location.origin;
    }
    originalURL = startUrl;
    await commands.open(theseOptions["starturl"]?theseOptions["starturl"]:startUrl);
   /* addOutput("Enter 'display' to view the page or 'links' to see available links."); */
    toggleInputLine(true);
}

    async function zinitialize() {
    toggleInputLine(false);
    let startUrl="";
    if (theseOptions["starturl"]==undefined) {startUrl = theseOptions["starturl"];}
    else
    {
    let startUrl = document.referrer;
    if (!startUrl || startUrl.split('/')[2].split(':')[0].split(':')[0]!="michaelkupietz.com"){
        startUrl = window.location.origin;
    }
    }
    
    originalURL = startUrl;
    await commands.open(startUrl);
   /* addOutput("Enter 'display' to view the page or 'links' to see available links."); */
    toggleInputLine(true);
}


        initialize();
    </script>
</body>
</html>
